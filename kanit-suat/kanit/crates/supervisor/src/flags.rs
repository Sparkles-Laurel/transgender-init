use std::fmt;
use std::fmt::Formatter;
use std::str::FromStr;

#[cfg(feature = "rkyv")]
use rkyv::Archive;
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "serde", serde(rename_all = "kebab-case"))]
#[cfg_attr(feature = "rkyv", derive(Archive, rkyv::Serialize, rkyv::Deserialize))]
#[cfg_attr(feature = "rkyv", archive(check_bytes))]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RestartPolicy {
    Never,
    Always,
    OnSuccess,
    OnFailure,
}

#[derive(Debug, PartialEq, Eq)]
pub struct ParseRestartModeError;

impl fmt::Display for ParseRestartModeError {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "expected `never`, `always`, `on-success`, or `on-failure`"
        )
    }
}

impl FromStr for RestartPolicy {
    type Err = ParseRestartModeError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "never" => Ok(Self::Never),
            "always" => Ok(Self::Always),
            "on-success" => Ok(Self::OnSuccess),
            "on-failure" => Ok(Self::OnFailure),
            _ => Err(ParseRestartModeError),
        }
    }
}

impl fmt::Display for RestartPolicy {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            Self::Never => write!(f, "never"),
            Self::Always => write!(f, "always"),
            Self::OnSuccess => write!(f, "on-success"),
            Self::OnFailure => write!(f, "on-failure"),
        }
    }
}

#[cfg(feature = "cli")]
xflags::xflags! {
    src "./src/flags.rs"

    cmd supervisor {
        /// Delay used before restarting an exited process.
        optional -d, --restart-delay delay: u64
        /// Amount of times to restart a process before giving up.
        optional -a, --restart-attempts attempts: u64
        /// Policy to use before restarting, either `never`, `always`, `on-success`, or `on-failure`.
        optional -P, --restart-policy policy: RestartPolicy
        /// Set the working directory.
        optional -p, --pwd pwd: String
        /// Set the root directory.
        optional -r, --root root: String
        /// Set an environment variable (NAME=VAR).
        repeated -e, --env pair: String
        /// Set the process group.
        optional -g, --group gid: String
        /// Set the process user.
        optional -u, --user uid: String
        /// Redirect stdout to path.
        optional --stdout path: String
        /// Redirect stderr to path.
        optional --stderr path: String
        /// Command to execute.
        required cmd: String
        /// Arguments passed to the command.
        repeated args: String
    }
}

#[derive(Clone, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "serde", serde(rename_all = "kebab-case"))]
#[cfg_attr(feature = "serde", serde(default))]
#[cfg_attr(feature = "rkyv", derive(Archive, rkyv::Serialize, rkyv::Deserialize))]
#[cfg_attr(feature = "rkyv", archive(check_bytes))]
// TODO; paths should be paths
// impl needs to be marked `#[cfg(feature = "cli")]`
// generated start
// The following code is generated by `xflags` macro.
// Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
#[derive(Debug)]
pub struct Supervisor {
    pub cmd: String,
    pub args: Vec<String>,

    pub restart_delay: Option<u64>,
    pub restart_attempts: Option<u64>,
    pub restart_policy: Option<RestartPolicy>,
    pub pwd: Option<String>,
    pub root: Option<String>,
    pub env: Vec<String>,
    pub group: Option<String>,
    pub user: Option<String>,
    pub stdout: Option<String>,
    pub stderr: Option<String>,
}

#[cfg(feature = "cli")]
impl Supervisor {
    #[allow(dead_code)]
    pub fn from_env_or_exit() -> Self {
        Self::from_env_or_exit_()
    }

    #[allow(dead_code)]
    pub fn from_env() -> xflags::Result<Self> {
        Self::from_env_()
    }

    #[allow(dead_code)]
    pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
        Self::from_vec_(args)
    }
}
// generated end
